# Tutorial

## Usage principles

`scbs` provides a number of commands.
To view the available commands, simply install `scbs` and then type `scbs --help` (or just `scbs`) in your terminal.
Similarly, you can use `scbs [command] --help` to learn about each command and their arguments.
For example, use `scbs prepare --help` to learn how to use the `prepare` command.

A typical `scbs` workflow consists of the following steps which will be explained in the course of this tutorial:
1. use `scbs prepare` to store single-cell methylation data in an efficient format
2. use `scbs scan` to discover methylation-variable regions in the genome, or alternatively provide your own regions of interest
3. use `scbs matrix` to receive a matrix analogous to the count matrix in scRNA-seq
4. use the matrix for downstream analysis such as dimensionality reduction and clustering


### What you will need

`scbs` assumes that you
- used single-cell bisulfite-sequencing (scBS) to generate FASTQ-files of bisulfite-converted reads
- mapped the reads with a methylation-aware program
- extracted context-dependent methylation values (typically CpG) from the alignments

The last two steps can be achieved with bulk bisulfite-sequencing tools such as [Bismark](https://www.bioinformatics.babraham.ac.uk/projects/bismark/) and the included `bismark_methylation_extractor` script.
Afterwards, you should be left with a simple tabular file for each cell.
Each file contains the methylation status of thousands of methylation sites (typically CpG-sites) in the whole genome.
Here are the first five lines of an example file, which is a `.cov`-file generated by Bismark:

```
1       100021800       100021800       100.000000      1       0
1       100023064       100023064       0.000000        0       1
1       100026855       100026855       100.000000      1       0
1       100027218       100027218       100.000000      2       0
1       100051671       100051671       0.000000        0       2
```

You should have one of these files per cell.

The columns denote the chromosome name, the start and end coordinates of the methylation site (identical in this case), the observed percentage of methylation (typically 0% or 100% in single-cell data), the number of reads that are methylated at that site, and the number of unmethylated reads.
If you did not use Bismark and your files have a slightly different format, don't worry.
We support a range of different input formats and you can even define your own custom format.

`scbs` supports both uncompressed and gzip-compressed input files, as long as any gzipped files end in `.gz`.


## Download our tutorial data set

In this tutorial, we will analyze a small example data set with just 30 cells. If you want to follow along and try it yourself, you can download the data here:
[scbs_tutorial_data.tar.gz](https://heibox.uni-heidelberg.de/f/0a74cc5fd8a141a4bab8/?dl=1) and unpack it with `tar -xvzf scbs_tutorial_data.tar.gz`.


### 1. Preparing your `scbs` run

The first step of any `scbs` workflow is to collect the methylation data of all single-cell files in order to store it in a more efficient format.
This can be achieved with the commands `scbs prepare` and `scbs smooth`:

```bash
scbs prepare scbs_tutorial_data/*.cov compact_data
scbs smooth compact_data
```

This command will take all files ending in `.cov.gz` in the `scbs_tutorial_data` directory and efficiently store their methylation values in a new directory called `compact_data`.
`scbs prepare` is the only step that requires the raw data, all other `scbs` commands work directly with `compact_data`.
If you're working with your own data and you sequenced thousands of cells, `scbs prepare` will take quite long. But fortunately, you only have to run it once in the very beginning.


### 2. Discovering methylation-variable regions

The starting point of any single-cell RNA-seq experiment is a gene × cell (or cell × gene) count matrix that can be used for downstream analyses such as dimensionality reduction or clustering.
But single-cell methylation data is genome-wide and not limited to genes, hence we need to define genomic regions of interest.
A common strategy is to simply quantify methylation at promoters or gene bodies.
But not all methylation differences occur at promoters or gene bodies, hence we propose to discover methylation-variable regions (MVRs) in the data itself.
This can be achieved with `scbs scan`:

```bash
scbs scan --threads 4 compact_data MVRs.bed
```
We use the option `--threads 4` in order to run the program on 4 CPU threads in parallel. If you want to use all available threads, simply omit the `--threads` option altogether.
The result is a [BED-file](https://en.wikipedia.org/wiki/BED_(file_format)) that lists the genomic coordinates (chromosome, start, end) of regions where methylation is variable between cells, as well as the methylation variance of the region.


### 3. Getting a methylation matrix

Finally, you can quantify the mean methylation of the MVRs that we just discovered using `scbs matrix`:
```bash
scbs matrix MVRs.bed compact_data MVR_matrix.csv
```
The result is a long table that lists the average methylation of all regions (here: MVRs) in all cells. We report two measures of methylation: the average methylation (`meth_frac`) and the shrunken residuals (`shrunken_residual`), which are less affected by random variations in read coverage and read positioning within the region.

If you want, you can also get a methylation matrix of specific genomic features that you are interested in.
For example, here we quantify methylation of promoters in the mouse genome:
```bash
scbs matrix scbs_tutorial_data/mouse_promoters.bed compact_data promoter_matrix.csv
```

**(TO DO: output the data in a sane format cause long tables are too unwieldy if you have thousands of cells, then adjust the tutorial)**



### 4. Downstream analysis

Now we can import our methylation matrix into a scripting language of our choice for downstream analysis.
In this tutorial, we chose to use R.
We read the matrix and create a new column `region` that denotes the genomic coordinates of each region.
Next, we pivot the matrix from the long table format into a standard cell × region format.
Here we chose to use the shrunken residuals as our measure of methylation.
Finally, we transform the dataframe into a matrix.

```r
library(tidyverse)
library(irlba)

meth_mtx <- read_csv("MVR_matrix.csv") %>% 
  unite("region", c("chromosome", "start", "end")) %>% 
  pivot_wider("cell_name", names_from = "region", values_from = "shrunken_residual") %>% 
  column_to_rownames(var="cell_name") %>% 
  as.matrix()
```

The methylation matrix is similar to a scRNA-seq count matrix, but one major difference is that it contains missing values.
This is because the coverage of every single cell is low, which means that there are plenty of genomic intervals that did not receive a single sequencing read.
To counter this, we propose a simple and straightforward way to deal with missing data in the input matrix to a PCA: In a first iteration, we replace each missing value in the centered input matrix with zero, then run the PCA. Then, these zeroes are replaced by the value predicted by the PCA and the PCA is rerun.

Below, you can find an R function that implements this approach:
```r
# PCA that iteratively imputes missing values
prcomp_iterative <- function(x, n=10, n_iter=100, min_gain=0.01, ...) {
  mse <- rep(NA, n_iter)
  na_loc <- is.na(x)
  x[na_loc] = 0  # zero is our first guess

  for (i in 1:n_iter) {
    prev_imp <- x[na_loc]  # what we imputed in the previous round
    # PCA on the imputed matrix
    pr <- prcomp_irlba(x, center = F, scale. = F, n = n, ...)
    # impute missing values with PCA
    new_imp <- (pr$x %*% t(pr$rotation))[na_loc]
    x[na_loc] <- new_imp
    # compare our new imputed values to the ones from the previous round
    mse[i] = mean((prev_imp - new_imp) ^ 2)
    # if the values didn't change a lot, terminate the iteration
    gain <- mse[i] / max(mse, na.rm = T)
    if (gain < min_gain) {
      message(paste(c("\n\nTerminated after ", i, " iterations.")))
      break
    }
  }
  pr$mse_iter <- mse[1:i]
  pr
}
```

We simply run our modified PCA on the centered methylation matrix...
```r
pca <- meth_mtx %>%
  scale(center = T, scale = F) %>%
  prcomp_iterative(n = 5, n_iter = 5)
```

...and then plot the PCA, revealing three cell types with distinct methylomes:
```r
pca$x %>% 
  as_tibble() %>% 
  ggplot(aes(x = PC1, y = PC2)) +
  geom_point() +
  coord_fixed()
```

<img src="tutorial_PCA.png" width="300" height="300">

Of course you can also use PCA on the promoter methylation matrix instead of the MVR matrix by simply loading `promoter_matrix.csv` instead of `MVR_matrix.csv`.
This matrix yields a visually similar PCA, although the three cell types are not as cleanly separated:

<img src="tutorial_PCA_promoter.png" width="300" height="300">




### Advanced usage

#### Using stdin and stdout
If you want to use stdin and stdout instead of providing input/output file paths, you can use the `-` character where you would otherwise write the path to the file.
This makes it easy to incorporate other tools such as `bedtools` into your workflows.
For example, consider a workflow where you first want to sort your genomic input regions with `bedtools sort`, then you want to quantify methylation at these regions with `scbs matrix`, and then you want to compress the resulting matrix:
```bash
bedtools sort -i unsorted.bed > sorted.bed
scbs matrix sorted.bed compact_data matrix.csv
gzip matrix.csv
```
Using stdin and stdout, this workflow can be simplified:
```bash
bedtools sort -i unsorted.bed | scbs matrix - compact_data - | gzip > matrix.csv.gz
```
